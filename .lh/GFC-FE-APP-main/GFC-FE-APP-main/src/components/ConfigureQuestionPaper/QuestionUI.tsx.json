{
    "sourceFile": "GFC-FE-APP-main/GFC-FE-APP-main/src/components/ConfigureQuestionPaper/QuestionUI.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1752655154231,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752659215086,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -129,9 +129,10 @@\n     } else {\r\n       const accordionRect = document.getElementById(currentFocusedQuestionId)?.getBoundingClientRect();\r\n       if (accordionRect) {\r\n         const scrollTop = document.getElementsByClassName('question-form')[0].scrollTop;\r\n-        let targetTopRelativeToDiv = accordionRect.top - 120 + scrollTop;\r\n+        // Adjust for drag indicator box height and margins to align toolkit top with question box top border\r\n+        let targetTopRelativeToDiv = accordionRect.top - 120 + scrollTop + 28;\r\n         setYOffset(targetTopRelativeToDiv);\r\n       }\r\n     }\r\n   }\r\n"
                },
                {
                    "date": 1752660080822,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -129,10 +129,9 @@\n     } else {\r\n       const accordionRect = document.getElementById(currentFocusedQuestionId)?.getBoundingClientRect();\r\n       if (accordionRect) {\r\n         const scrollTop = document.getElementsByClassName('question-form')[0].scrollTop;\r\n-        // Adjust for drag indicator box height and margins to align toolkit top with question box top border\r\n-        let targetTopRelativeToDiv = accordionRect.top - 120 + scrollTop + 28;\r\n+        let targetTopRelativeToDiv = accordionRect.top - 120 + scrollTop;\r\n         setYOffset(targetTopRelativeToDiv);\r\n       }\r\n     }\r\n   }\r\n"
                },
                {
                    "date": 1752662964308,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,8 +42,42 @@\n   useEffect(() => {\r\n     updateToolBoxPosition();\r\n   }, [currentFocusedQuestionId, questions]);\r\n \r\n+  // Specifically handle when currentFocusedQuestionId changes\r\n+  useEffect(() => {\r\n+    if (currentFocusedQuestionId) {\r\n+      // Add a longer delay to ensure DOM elements are properly rendered and positioned\r\n+      setTimeout(() => {\r\n+        const element = document.getElementById(currentFocusedQuestionId);\r\n+        if (element) {\r\n+          updateToolBoxPosition();\r\n+        }\r\n+      }, 100);\r\n+    }\r\n+  }, [currentFocusedQuestionId]);\r\n+\r\n+  // Initialize toolkit position on component mount\r\n+  useEffect(() => {\r\n+    if (questions.length > 0 && !viewDocument) {\r\n+      // Set initial position to first question if none is focused\r\n+      const initializePosition = () => {\r\n+        if (!currentFocusedQuestionId && questions[0]) {\r\n+          const firstQuestionRect = document.getElementById(questions[0]._id)?.getBoundingClientRect();\r\n+          const containerRect = document.getElementsByClassName('question-form')[0]?.getBoundingClientRect();\r\n+          if (firstQuestionRect && containerRect) {\r\n+            const scrollTop = document.getElementsByClassName('question-form')[0].scrollTop;\r\n+            const relativeTop = firstQuestionRect.top - containerRect.top + scrollTop + 40;\r\n+            setYOffset(Math.max(0, relativeTop));\r\n+          }\r\n+        }\r\n+      };\r\n+      \r\n+      // Add small delay to ensure DOM elements are fully rendered\r\n+      setTimeout(initializePosition, 100);\r\n+    }\r\n+  }, [questions, viewDocument]);\r\n+\r\n   const updateDocument = (): void => {\r\n     handlePromiseRequest(async () => {\r\n       let payload = {\r\n         _id: params.documentId,\r\n@@ -105,39 +139,78 @@\n     }\r\n   }\r\n \r\n   const isElementBoxVisible = (): boolean => {\r\n-    let elementRect = document.getElementById(currentFocusedQuestionId)?.getBoundingClientRect() || { top: 0, bottom: 0 };\r\n-    let containerRect = document.getElementsByClassName('question-form')[0]?.getBoundingClientRect();\r\n-    return elementRect?.top >= containerRect?.top && elementRect.bottom <= containerRect.bottom;\r\n+    const currentElement = document.getElementById(currentFocusedQuestionId);\r\n+    const containerElement = document.getElementsByClassName('question-form')[0];\r\n+    \r\n+    if (!currentElement || !containerElement) {\r\n+      return false;\r\n+    }\r\n+    \r\n+    const elementRect = currentElement.getBoundingClientRect();\r\n+    const containerRect = containerElement.getBoundingClientRect();\r\n+    \r\n+    return elementRect.top >= containerRect.top && \r\n+           elementRect.bottom <= containerRect.bottom && \r\n+           elementRect.top < containerRect.bottom - 100; // Add some buffer\r\n   }\r\n \r\n   // Function to handle scroll event\r\n   const handleScrollFunction = (event: any) => {\r\n-    if (isElementBoxVisible()) {\r\n+    const scrollTop = event.target.scrollTop;\r\n+    \r\n+    if (currentFocusedQuestionId && isElementBoxVisible()) {\r\n       updateToolBoxPosition();\r\n-    } else {\r\n-      setYOffset(event.target.scrollTop);\r\n+    } else if (currentFocusedQuestionId) {\r\n+      // Position toolkit relative to the focused question even if not visible\r\n+      const currentElement = document.getElementById(currentFocusedQuestionId);\r\n+      if (currentElement) {\r\n+        const elementRect = currentElement.getBoundingClientRect();\r\n+        const containerRect = document.getElementsByClassName('question-form')[0]?.getBoundingClientRect();\r\n+        const relativeTop = elementRect.top - containerRect.top + scrollTop + 40;\r\n+        setYOffset(Math.max(0, relativeTop));\r\n+      }\r\n     }\r\n   };\r\n \r\n   const handleScroll = debounce(handleScrollFunction, 50);\r\n \r\n   // updates tool box position when new question box is added\r\n   const handleUpdateToolBoxPosition = (): void => {\r\n+    if (!currentFocusedQuestionId) {\r\n+      return;\r\n+    }\r\n+    \r\n+    const currentElement = document.getElementById(currentFocusedQuestionId);\r\n+    const containerElement = document.getElementsByClassName('question-form')[0];\r\n+    \r\n+    if (!currentElement || !containerElement) {\r\n+      return;\r\n+    }\r\n+    \r\n     if (!isElementBoxVisible()) {\r\n-      document.getElementById(currentFocusedQuestionId)?.scrollIntoView({ behavior: 'smooth', block: 'center' })\r\n+      currentElement.scrollIntoView({ behavior: 'smooth', block: 'center' });\r\n+      // After scrolling, update position\r\n+      setTimeout(() => {\r\n+        const updatedElementRect = currentElement.getBoundingClientRect();\r\n+        const updatedContainerRect = containerElement.getBoundingClientRect();\r\n+        const scrollTop = containerElement.scrollTop;\r\n+        const targetTopRelativeToContainer = updatedElementRect.top - updatedContainerRect.top + scrollTop + 40;\r\n+        setYOffset(Math.max(0, targetTopRelativeToContainer));\r\n+      }, 300);\r\n     } else {\r\n-      const accordionRect = document.getElementById(currentFocusedQuestionId)?.getBoundingClientRect();\r\n-      if (accordionRect) {\r\n-        const scrollTop = document.getElementsByClassName('question-form')[0].scrollTop;\r\n-        let targetTopRelativeToDiv = accordionRect.top - 120 + scrollTop;\r\n-        setYOffset(targetTopRelativeToDiv);\r\n-      }\r\n+      const accordionRect = currentElement.getBoundingClientRect();\r\n+      const containerRect = containerElement.getBoundingClientRect();\r\n+      const scrollTop = containerElement.scrollTop;\r\n+      \r\n+      // Calculate position relative to the container with offset for proper alignment\r\n+      const targetTopRelativeToContainer = accordionRect.top - containerRect.top + scrollTop + 40;\r\n+      setYOffset(Math.max(0, targetTopRelativeToContainer));\r\n     }\r\n   }\r\n \r\n-  const updateToolBoxPosition = debounce(handleUpdateToolBoxPosition, 300);\r\n+  const updateToolBoxPosition = debounce(handleUpdateToolBoxPosition, 100);\r\n \r\n   function onDragEnd(result: any) {\r\n     if (!result.destination) {\r\n       return;\r\n@@ -186,8 +259,14 @@\n \r\n   const addQuestionTemplate = (): void => {\r\n     closeAllExpandedQuestion();\r\n     dispatch({ type: QUESTION_ACTION_TYPES.ADD_NEW_QUESTION });\r\n+    \r\n+    // Update toolkit position after new question is added with a longer delay to ensure DOM is updated\r\n+    setTimeout(() => {\r\n+      updateToolBoxPosition();\r\n+    }, 400);\r\n+    \r\n     toast.success('Question added', {\r\n       position: \"bottom-right\"\r\n     });\r\n   }\r\n"
                }
            ],
            "date": 1752655154231,
            "name": "Commit-0",
            "content": "import AddCircleOutlineIcon from '@mui/icons-material/AddCircleOutline';\r\nimport CreateIcon from '@mui/icons-material/Create';\r\nimport CropOriginalIcon from '@mui/icons-material/CropOriginal';\r\nimport DragIndicatorIcon from '@mui/icons-material/DragIndicator';\r\nimport OndemandVideoIcon from '@mui/icons-material/OndemandVideo';\r\nimport TextFieldsIcon from '@mui/icons-material/TextFields';\r\nimport { Accordion, Button, debounce, Tooltip } from \"@mui/material\";\r\nimport AccordionDetails from '@mui/material/AccordionDetails';\r\nimport AccordionSummary from '@mui/material/AccordionSummary';\r\nimport { useEffect, useState } from \"react\";\r\nimport { DragDropContext, Draggable, Droppable } from \"react-beautiful-dnd\";\r\nimport toast from 'react-hot-toast';\r\nimport { useNavigate, useParams } from 'react-router-dom';\r\nimport { Question } from \"../../utils/Question\";\r\nimport useAxios from '../../utils/axios';\r\nimport { Answers, HTTP_METHODS, QUESTION_ACTION_TYPES, QUESTION_TYPES, REQUEST_FAILURE_MESSAGES, REQUEST_SUCCESS_MESSAGES, REQUEST_URLS, ROUTE_PATHS } from \"../../utils/constants\";\r\nimport { getCurrentDateTime } from '../../utils/util';\r\nimport { DisplayQuestion } from './Displayquestion';\r\nimport { OptionBox } from './OptionBox';\r\nimport { QuestionBoxFooter } from './QuestionBoxFooter';\r\nimport \"./QuestionUI.scss\";\r\nimport { SelectBox } from './SelectBox';\r\nimport { useDocument } from 'components/contexts/questions-context';\r\nimport ArrowBackIosNewIcon from '@mui/icons-material/ArrowBackIosNew';\r\n\r\nconst SAVING = 'Saving...';\r\nexport function QuestionForm() {\r\n  const [yoffset, setYOffset] = useState(0);\r\n  const [answers, setAnswers] = useState<Answers>();\r\n  let params = useParams();\r\n  let navigate = useNavigate();\r\n  let { HttpRequestController, isRequestPending, handlePromiseRequest } = useAxios();\r\n  let { questions, dispatch, currentFocusedQuestionId, documentName,\r\n    documentDescription, viewDocument, createdByUserID, user } = useDocument();\r\n\r\n  useEffect(() => {\r\n    if (viewDocument) {\r\n      closeAllExpandedQuestion();\r\n    }\r\n  }, [viewDocument]);\r\n\r\n  useEffect(() => {\r\n    updateToolBoxPosition();\r\n  }, [currentFocusedQuestionId, questions]);\r\n\r\n  const updateDocument = (): void => {\r\n    handlePromiseRequest(async () => {\r\n      let payload = {\r\n        _id: params.documentId,\r\n        documentName,\r\n        documentDescription,\r\n        questions,\r\n        updatedOn: getCurrentDateTime(),\r\n      }\r\n      await HttpRequestController(REQUEST_URLS.UPDATE_DOCUMENT, HTTP_METHODS.PUT, payload);\r\n    }, SAVING, REQUEST_SUCCESS_MESSAGES.QUESTIONS_SAVED_SUCCESSFULLY, REQUEST_FAILURE_MESSAGES.SAVING_QUESTIONS_FAILED)\r\n  }\r\n\r\n  const handleValueChange = (question: Question, value: string, option?: string, checked?: boolean) => {\r\n    if (question.questionType != QUESTION_TYPES.CHECKBOX) {\r\n      setAnswers({ ...answers, [question._id]: value });\r\n    } else {\r\n      const selectedOptions = answers?.[question._id] ?? [];\r\n      if (checked) {\r\n        setAnswers({ ...answers, [question._id]: [...selectedOptions, option] });\r\n      } else {\r\n        const updatedOptions = selectedOptions.filter((selected: string) => selected !== option);\r\n        return {\r\n          ...answers,\r\n          [question._id]: updatedOptions\r\n        };\r\n      }\r\n    }\r\n  };\r\n\r\n  const checkAllRequiredQuestionsAreAnswered = (): boolean => {\r\n    return questions.every((question: Question) => {\r\n      if (question.required) {\r\n        return answers?.hasOwnProperty(question._id);\r\n      } else {\r\n        return true;\r\n      }\r\n    });\r\n  }\r\n\r\n  const saveUserResponse = async (): Promise<void> => {\r\n    if (checkAllRequiredQuestionsAreAnswered()) {\r\n      let payload = {\r\n        documentId: params.documentId,\r\n        answers,\r\n        userId: user.userId,\r\n        username: user.username\r\n      }\r\n      await HttpRequestController(`${REQUEST_URLS.USER_RESPONSE}/${params.documentId}`, HTTP_METHODS.POST, payload);\r\n      toast.success(REQUEST_SUCCESS_MESSAGES.REQUEST_SAVED_SUCCESSFULLY);\r\n      navigate(`/thank-you/${params.documentId}`, { replace: true });\r\n    }\r\n  }\r\n\r\n  const submitUserResponse = () => {\r\n    if (checkAllRequiredQuestionsAreAnswered()) {\r\n      handlePromiseRequest(saveUserResponse, SAVING, REQUEST_SUCCESS_MESSAGES.REQUEST_SAVED_SUCCESSFULLY, REQUEST_FAILURE_MESSAGES.SAVING_USER_RESPONSE_FAILED)\r\n    } else {\r\n      toast.error(REQUEST_FAILURE_MESSAGES.PLEASE_ANSWER_ALL_REQUIRED_QUESTIONS);\r\n    }\r\n  }\r\n\r\n  const isElementBoxVisible = (): boolean => {\r\n    let elementRect = document.getElementById(currentFocusedQuestionId)?.getBoundingClientRect() || { top: 0, bottom: 0 };\r\n    let containerRect = document.getElementsByClassName('question-form')[0]?.getBoundingClientRect();\r\n    return elementRect?.top >= containerRect?.top && elementRect.bottom <= containerRect.bottom;\r\n  }\r\n\r\n  // Function to handle scroll event\r\n  const handleScrollFunction = (event: any) => {\r\n    if (isElementBoxVisible()) {\r\n      updateToolBoxPosition();\r\n    } else {\r\n      setYOffset(event.target.scrollTop);\r\n    }\r\n  };\r\n\r\n  const handleScroll = debounce(handleScrollFunction, 50);\r\n\r\n  // updates tool box position when new question box is added\r\n  const handleUpdateToolBoxPosition = (): void => {\r\n    if (!isElementBoxVisible()) {\r\n      document.getElementById(currentFocusedQuestionId)?.scrollIntoView({ behavior: 'smooth', block: 'center' })\r\n    } else {\r\n      const accordionRect = document.getElementById(currentFocusedQuestionId)?.getBoundingClientRect();\r\n      if (accordionRect) {\r\n        const scrollTop = document.getElementsByClassName('question-form')[0].scrollTop;\r\n        let targetTopRelativeToDiv = accordionRect.top - 120 + scrollTop;\r\n        setYOffset(targetTopRelativeToDiv);\r\n      }\r\n    }\r\n  }\r\n\r\n  const updateToolBoxPosition = debounce(handleUpdateToolBoxPosition, 300);\r\n\r\n  function onDragEnd(result: any) {\r\n    if (!result.destination) {\r\n      return;\r\n    }\r\n    let itemgg = [...questions];\r\n    const itemF = reorder(\r\n      itemgg,\r\n      result.source.index,\r\n      result.destination.index\r\n    );\r\n    dispatch({\r\n      type: QUESTION_ACTION_TYPES.REORDER_QUESTIONS,\r\n      payload: {\r\n        questions: itemF as Question[]\r\n      }\r\n    });\r\n    toast.success('Questions swapped', {\r\n      position: \"bottom-right\"\r\n    });\r\n  }\r\n\r\n  const reorder = (list: any, startIndex: number, endIndex: number) => {\r\n    const result = Array.from(list);\r\n    const [removed] = result.splice(startIndex, 1);\r\n    result.splice(endIndex, 0, removed);\r\n    return result;\r\n  };\r\n\r\n  const closeAllExpandedQuestion = (): void => {\r\n    dispatch({ type: QUESTION_ACTION_TYPES.CLOSE_EXPANDED_QUESTIONS });\r\n  }\r\n\r\n  const handleExpand = (questionIndex: number): void => {\r\n    dispatch({\r\n      type: QUESTION_ACTION_TYPES.EXPAND_QUESTION,\r\n      payload: { questionIndex }\r\n    });\r\n  }\r\n\r\n  const updateQuestion = (question: string, questionIndex: number): void => {\r\n    dispatch({\r\n      type: QUESTION_ACTION_TYPES.UPDATE_QUESTION,\r\n      payload: { questionIndex, questionText: question }\r\n    });\r\n  }\r\n\r\n  const addQuestionTemplate = (): void => {\r\n    closeAllExpandedQuestion();\r\n    dispatch({ type: QUESTION_ACTION_TYPES.ADD_NEW_QUESTION });\r\n    toast.success('Question added', {\r\n      position: \"bottom-right\"\r\n    });\r\n  }\r\n\r\n  const displayQuestions = () => {\r\n    return questions.map((question: Question, i: any) => {\r\n      return <Draggable key={question._id} draggableId={question._id} index={i} isDragDisabled={viewDocument}>\r\n        {(provided) => (\r\n          <div id={question._id} ref={provided.innerRef}  {...provided.draggableProps} {...provided.dragHandleProps}>\r\n            <div>\r\n              <div className={viewDocument ? \"question-container add-margin\" : \"question-container\"}>\r\n                {\r\n                  !viewDocument && (\r\n                    <div className=\"drag-indicator-box\">\r\n                      <DragIndicatorIcon className=\"icon\" fontSize=\"small\" />\r\n                    </div>\r\n                  )\r\n                }\r\n                <Accordion onChange={() => {\r\n                  if (!viewDocument) {\r\n                    handleExpand(i);\r\n                  }\r\n                }} expanded={questions[i].open} className={questions[i].open ? \"MuiAccordion-root add-border\" : \"MuiAccordion-root\"}>\r\n                  <AccordionSummary aria-controls=\"panel1-content\" id=\"panel1-header\">\r\n                    {(!questions[i].open) && (\r\n                      <DisplayQuestion questionIndex={i} question={question}\r\n                        showQuestionPaper={viewDocument} onChange={handleValueChange} />\r\n                    )}\r\n                  </AccordionSummary>\r\n                  <div className=\"question-box\">\r\n                    <AccordionDetails className=\"add-question\">\r\n                      <div>\r\n                        <div className=\"add-question-top\">\r\n                          <textarea className=\"question\"\r\n                            placeholder=\"Question\" value={question.question} onChange={(e) => { updateQuestion(e.target.value, i) }} />\r\n                          {/* selection box to select question type  */}\r\n                          <SelectBox questionIndex={i} question={question} />\r\n                        </div>\r\n                        {/* adding options */}\r\n                        <OptionBox question={question} questionIndex={i} />\r\n                        {/* question box footer with action buttons  */}\r\n                        <QuestionBoxFooter isRequired={question.required} questionIndex={i} />\r\n                      </div>\r\n                    </AccordionDetails>\r\n                  </div>\r\n                </Accordion>\r\n              </div>\r\n            </div>\r\n          </div >\r\n        )\r\n        }\r\n      </Draggable >\r\n    })\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <div className={viewDocument ? \" question-form question-paper-full-height\" : \"question-form\"} id=\"question-form\" onScroll={handleScroll}>\r\n        <div className=\"section\">\r\n          <div className=\"question-title-section\">\r\n            <div className=\"question-form-top\">\r\n              <input\r\n                type=\"text\"\r\n                className=\"question-form-top-name\"\r\n                placeholder=\"Untitled form\"\r\n                value={documentName}\r\n                onChange={(e) => {\r\n                  dispatch({ type: QUESTION_ACTION_TYPES.UPDATE_DOCUMENT_NAME, payload: { documentName: e.target.value } });\r\n                }}\r\n                readOnly={viewDocument}\r\n              />\r\n              <input\r\n                type=\"text\"\r\n                className=\"question-form-top-desc\"\r\n                placeholder=\"Document description\"\r\n                value={documentDescription}\r\n                onChange={(e) => {\r\n                  dispatch({ type: QUESTION_ACTION_TYPES.UPDATE_DOCUMENT_DESCRIPTION, payload: { documentDescription: e.target.value } });\r\n                }}\r\n                readOnly={viewDocument}\r\n              />\r\n            </div>\r\n          </div>\r\n          {\r\n            questions && (<DragDropContext onDragEnd={onDragEnd}>\r\n              <Droppable droppableId=\"questions\">\r\n                {(provided) => (\r\n                  <div {...provided.droppableProps} ref={provided.innerRef}>\r\n                    {displayQuestions()}\r\n                    {provided.placeholder}\r\n                  </div>\r\n                )}\r\n              </Droppable>\r\n            </DragDropContext>\r\n            )\r\n          }\r\n\r\n          <div className=\"save-form\">\r\n            <Button\r\n              className=\"save-button\"\r\n              variant=\"contained\"\r\n              color=\"success\"\r\n              disabled={isRequestPending}\r\n              onClick={!viewDocument ? updateDocument : submitUserResponse} >\r\n              {viewDocument ? \"Submit\" : \"Save\"}\r\n            </Button>\r\n          </div>\r\n        </div>\r\n        {\r\n          !viewDocument && (<div className=\"question-edit\" style={{ top: `${yoffset}px` }}>\r\n            <Tooltip title=\"Add question\" placement=\"right\">\r\n              <AddCircleOutlineIcon className=\"edit add-question-btn\" onClick={() => addQuestionTemplate()} />\r\n            </Tooltip>\r\n            <OndemandVideoIcon className=\"edit\" />\r\n            <CropOriginalIcon className=\"edit\" />\r\n            <TextFieldsIcon className=\"edit\" />\r\n          </div>)\r\n        }\r\n      </div>\r\n      {/* display this edit icon when user is viewing the document */}\r\n      {user.userId === createdByUserID && viewDocument && (\r\n        <Tooltip title=\"Edit\">\r\n          <CreateIcon className=\"edit-question-paper-icon\" onClick={() => dispatch({\r\n            type: QUESTION_ACTION_TYPES.VIEW_DOCUMENT\r\n          })} />\r\n        </Tooltip>)\r\n      }\r\n\r\n      {user.userId === createdByUserID && viewDocument && (\r\n        <div className=\"back-button\">\r\n          <Tooltip title=\"Go Back\">\r\n            <ArrowBackIosNewIcon className=\"edit-question-paper-icon\" onClick={() => {\r\n              dispatch({\r\n                type: QUESTION_ACTION_TYPES.VIEW_DOCUMENT\r\n              })\r\n            }} />\r\n          </Tooltip>\r\n        </div>)\r\n      }\r\n\r\n    </div >\r\n  )\r\n}\r\n"
        }
    ]
}