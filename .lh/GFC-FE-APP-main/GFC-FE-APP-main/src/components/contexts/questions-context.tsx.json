{
    "sourceFile": "GFC-FE-APP-main/GFC-FE-APP-main/src/components/contexts/questions-context.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1752948184967,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1752948184967,
            "name": "Commit-0",
            "content": "import { createContext, useContext, useReducer, useEffect, useState } from \"react\";\r\nimport { useParams } from \"react-router-dom\";\r\nimport useAxios from \"utils/axios\";\r\nimport {\r\n  REQUEST_URLS, HTTP_METHODS, QUESTION_ACTION_TYPES, DocumentInitialState,\r\n  LOADING, INTERNAL_SERVER_ERROR, REQUEST_SUCCESS_MESSAGES, REQUEST_FAILURE_MESSAGES,\r\n  SOCKET_CHANNEL_NAMES, ResponseData\r\n} from \"utils/constants\";\r\nimport { Question } from \"utils/Question\";\r\nimport socket from \"utils/SocketManager\";\r\nimport { useAuth } from \"./auth-context\";\r\n\r\nconst DocumentContext = createContext<null | any>(null);\r\n\r\n// initial state of the document\r\nconst initialState: DocumentInitialState = {\r\n  questions: [],\r\n  documentName: \"\",\r\n  documentDescription: '',\r\n  currentFocusedQuestionId: 'sdd',\r\n  currQueIndex: 0,\r\n  viewDocument: false,\r\n  createdByUserID: ''\r\n};\r\n\r\n// updated the state based on the user actions\r\nfunction reducer(state: any, action: any) {\r\n  let queIdx = action.payload?.questionIndex;\r\n\r\n  switch (action.type) {\r\n    // \r\n    case QUESTION_ACTION_TYPES.DOCUMENT_LOADED: {\r\n      return {\r\n        ...state,\r\n        documentName: action.payload?.documentName,\r\n        documentDescription: action.payload?.documentDescription,\r\n        questions: action.payload?.questions.map((question: Question) => {\r\n          question.open = false;\r\n          return new Question(question);\r\n        }),\r\n        createdByUserID: action.payload.createdByUserID,\r\n        currentFocusedQuestionId: action.payload.questions[0]?._id || ''\r\n      };\r\n    }\r\n\r\n    // closes the focused question box\r\n    case QUESTION_ACTION_TYPES.CLOSE_EXPANDED_QUESTIONS:\r\n      return {\r\n        ...state,\r\n        currentFocusedQuestionId: state.questions.length > 0 ? state.questions[0]._id : '',\r\n        questions: state.questions.map((question: Question) => {\r\n          return question.openAndCloseQuestion(false);\r\n        })\r\n      };\r\n\r\n    // opens the focused question box\r\n    case QUESTION_ACTION_TYPES.EXPAND_QUESTION:\r\n      return {\r\n        ...state,\r\n        currQueIndex: queIdx,\r\n        questions: state.questions.map((question: Question, j: number) => {\r\n          return question.openAndCloseQuestion(queIdx == j);\r\n        }),\r\n        currentFocusedQuestionId: state.questions[queIdx]._id\r\n      };\r\n\r\n    // updates the question\r\n    case QUESTION_ACTION_TYPES.UPDATE_QUESTION:\r\n      {\r\n        let questionText = action.payload.questionText;\r\n        let currentQuestions = [...state.questions];\r\n        currentQuestions[queIdx].updateQuestion(questionText);\r\n        return {\r\n          ...state,\r\n          currQueIndex: queIdx,\r\n          questions: currentQuestions,\r\n          currentFocusedQuestionId: state.questions[queIdx]._id\r\n        };\r\n      }\r\n\r\n    // adds new option to the question\r\n    case QUESTION_ACTION_TYPES.ADD_NEW_OPTION:\r\n      {\r\n        let currentQuestions = [...state.questions];\r\n        currentQuestions[queIdx].addNewOption();\r\n        return {\r\n          ...state,\r\n          currQueIndex: queIdx,\r\n          questions: currentQuestions,\r\n          currentFocusedQuestionId: state.questions[queIdx]._id\r\n        };\r\n      }\r\n\r\n    // remove the option from a question  \r\n    case QUESTION_ACTION_TYPES.REMOVE_OPTION:\r\n      {\r\n        let optIndex = action.payload.optionIndex;\r\n        let currentQuestions = [...state.questions];\r\n        currentQuestions[queIdx].removeOption(optIndex);\r\n        return {\r\n          ...state,\r\n          currQueIndex: queIdx,\r\n          questions: currentQuestions,\r\n          currentFocusedQuestionId: state.questions[queIdx]._id\r\n        };\r\n      }\r\n\r\n    // adds new question to the document\r\n    case QUESTION_ACTION_TYPES.ADD_NEW_QUESTION:\r\n      {\r\n        let currentQuestions = [...state.questions];\r\n        let newQue = new Question();\r\n        currentQuestions.splice(state.currQueIndex + 1, 0, newQue);\r\n        return {\r\n          ...state,\r\n          currQueIndex: state.currQueIndex + 1,\r\n          questions: currentQuestions,\r\n          currentFocusedQuestionId: newQue._id\r\n        };\r\n      }\r\n\r\n    // updating the question type like radio, checkbox, text, date and time\r\n    case QUESTION_ACTION_TYPES.UPDATE_QUESTION_TYPE:\r\n      {\r\n        let currentQuestions = [...state.questions];\r\n        currentQuestions[queIdx].updateQuestionType(action.payload.queType);\r\n        return {\r\n          ...state,\r\n          currQueIndex: queIdx,\r\n          questions: currentQuestions,\r\n          currentFocusedQuestionId: state.questions[queIdx]._id\r\n        };\r\n      }\r\n\r\n    // deletes the question\r\n    case QUESTION_ACTION_TYPES.DELETE_QUESTION:\r\n      {\r\n        let currentQuestions = [...state.questions];\r\n        currentQuestions.splice(queIdx, 1);\r\n        let index = queIdx - 1 > 0 ? queIdx - 1 : 0;\r\n\r\n        if (currentQuestions.length > 0) {\r\n          currentQuestions[index].openAndCloseQuestion(true);\r\n        }\r\n        return {\r\n          ...state,\r\n          currQueIndex: index,\r\n          questions: currentQuestions,\r\n          currentFocusedQuestionId: state.questions[index]._id\r\n        };\r\n      }\r\n\r\n    // copies the question\r\n    case QUESTION_ACTION_TYPES.COPY_QUESTION:\r\n      {\r\n        let currentQuestions = [...state.questions];\r\n        let copiedQuestion = currentQuestions[queIdx].copyQuestion();\r\n        currentQuestions.splice(queIdx + 1, 0, copiedQuestion);\r\n        return {\r\n          ...state,\r\n          currQueIndex: queIdx + 1,\r\n          questions: currentQuestions,\r\n          currentFocusedQuestionId: copiedQuestion._id\r\n        };\r\n      }\r\n\r\n    // sets question is required or not\r\n    case QUESTION_ACTION_TYPES.TOGGLE_REQUIRED:\r\n      {\r\n        let currentQuestions = [...state.questions];\r\n        currentQuestions[queIdx].updateRequiredType();\r\n        return {\r\n          ...state,\r\n          currQueIndex: queIdx,\r\n          questions: currentQuestions,\r\n          currentFocusedQuestionId: state.questions[queIdx]._id\r\n        };\r\n      }\r\n\r\n    // updated the option value for checkbox and radio type options\r\n    case QUESTION_ACTION_TYPES.HANDLE_OPTION_VALUE:\r\n      {\r\n        let optionValue = action.payload.optionValue;\r\n        let optIndex = action.payload.optionIndex\r\n        let currentQuestions = [...state.questions];\r\n        currentQuestions[queIdx].updateOption(optIndex, optionValue);\r\n        return {\r\n          ...state,\r\n          currQueIndex: queIdx,\r\n          questions: currentQuestions,\r\n          currentFocusedQuestionId: state.questions[queIdx]._id\r\n        };\r\n      }\r\n\r\n    // on drag and drop action it will update the sequence of questions\r\n    case QUESTION_ACTION_TYPES.REORDER_QUESTIONS:\r\n      {\r\n        return {\r\n          ...state,\r\n          questions: action.payload.questions\r\n        };\r\n      }\r\n\r\n    // updates the document name\r\n    case QUESTION_ACTION_TYPES.UPDATE_DOCUMENT_NAME:\r\n      return {\r\n        ...state,\r\n        documentName: action.payload.documentName\r\n      };\r\n\r\n    // updates the document description\r\n    case QUESTION_ACTION_TYPES.UPDATE_DOCUMENT_DESCRIPTION:\r\n      return {\r\n        ...state,\r\n        documentDescription: action.payload.documentDescription\r\n      };\r\n\r\n    // updates the viewDocument property\r\n    // when viewDocument is true, the question boxes will not be editable and toolmbox will not be visible\r\n    case QUESTION_ACTION_TYPES.VIEW_DOCUMENT:\r\n      return {\r\n        ...state,\r\n        viewDocument: !state.viewDocument\r\n      };\r\n  }\r\n}\r\n\r\n// provides the document data and document responses to the child components\r\nconst DocumentContextProvider: React.FC<any> = ({ children }) => {\r\n  let params = useParams();\r\n  let [formResponses, setFormResponses] = useState<ResponseData | any>([]);\r\n  let [rows, setRows] = useState<ResponseData | any>([]);\r\n  let { HttpRequestController, handlePromiseRequest, isRequestPending } = useAxios();\r\n  let { user } = useAuth();\r\n  const [\r\n    { questions, documentName, documentDescription, currQueIndex, currentFocusedQuestionId, viewDocument, createdByUserID }, dispatch\r\n  ] = useReducer(reducer, initialState);\r\n\r\n  // loades the document questions and options\r\n  const loadDocument = async () => {\r\n    let { document } = await HttpRequestController(REQUEST_URLS.GET_DOCUMENT + `/${params.documentId}`, HTTP_METHODS.GET);\r\n    if (document) {\r\n      dispatch({ type: QUESTION_ACTION_TYPES.DOCUMENT_LOADED, payload: document });\r\n    }\r\n  }\r\n\r\n  useEffect(() => {\r\n    handlePromiseRequest(loadDocument, LOADING, REQUEST_SUCCESS_MESSAGES.QUESTIONS_LOADED_SUCCESSFULLY, REQUEST_FAILURE_MESSAGES.QUESTIONS_LOADING_FAILED);\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    // when the user opens the document which is not created by him, then it\r\n    // will not retreive the responses for that document\r\n    if (createdByUserID === user.userId) {\r\n      // handlePromiseRequest(loadResponse, LOADING, '', INTERNAL_SERVER_ERROR);\r\n      loadResponse();\r\n    }\r\n  }, [createdByUserID])\r\n\r\n  let idCounter = 0;\r\n  // to create a new row, with new id\r\n  const createRow = (username: string, submittedOn: string) => {\r\n    return { id: ++idCounter, username, submittedOn };\r\n  };\r\n\r\n  const loadResponse = async () => {\r\n    let responseData = await HttpRequestController(REQUEST_URLS.USER_RESPONSE + `/${params.documentId}`, HTTP_METHODS.GET);\r\n    let rowsData = responseData.formResponses.map((formResponse: any) => {\r\n      return createRow(formResponse.userId.username, formResponse.submittedOn);\r\n    });\r\n    setFormResponses(responseData.formResponses);\r\n    setRows(rowsData);\r\n\r\n    // when ever other users submit the response for this document\r\n    // lively it will update the table with new row \r\n    socket.on(SOCKET_CHANNEL_NAMES.USER_RESPONSE, (newData: any) => {\r\n      if (newData.documentId == params.documentId) {\r\n        let newFormResponse = createRow(newData.userId.username, newData.submittedOn);\r\n        setRows([...rowsData, newFormResponse]);\r\n        setFormResponses([...responseData.formResponses, newData])\r\n      }\r\n    });\r\n  }\r\n\r\n  return (\r\n    <DocumentContext.Provider\r\n      value={{\r\n        questions, documentDescription, documentName, currQueIndex, currentFocusedQuestionId, viewDocument, createdByUserID, user,\r\n        dispatch, isRequestPending, rows, formResponses\r\n      }}\r\n    >\r\n      {children}\r\n    </DocumentContext.Provider>\r\n  );\r\n}\r\n\r\nconst useDocument = () => {\r\n  const context = useContext(DocumentContext);\r\n  if (context === undefined)\r\n    throw new Error(\"DocumentContext was used outside of the DocumentContextProvider\");\r\n  return context;\r\n}\r\n\r\nexport { DocumentContextProvider, useDocument };\r\n"
        }
    ]
}